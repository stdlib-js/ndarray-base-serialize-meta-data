{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/polyfill.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar IS_LITTLE_ENDIAN = require( '@stdlib/assert-is-little-endian' );\nvar ArrayBuffer = require( '@stdlib/array-buffer' );\nvar DataView = require( '@stdlib/array-dataview' );\nvar BigInt = require( '@stdlib/bigint-ctor' );\nvar bytesPerElement = require( '@stdlib/ndarray-base-bytes-per-element' );\nvar dtypes = require( '@stdlib/ndarray-dtypes' ).enum;\nvar orders = require( '@stdlib/ndarray-orders' ).enum;\nvar modes = require( '@stdlib/ndarray-index-modes' ).enum;\n\n\n// VARIABLES //\n\nvar DTYPES = dtypes();\nvar ORDERS = orders();\nvar MODES = modes();\n\n\n// MAIN //\n\n/**\n* Serializes ndarray meta data.\n*\n* ## Notes\n*\n* -   This function takes into account ndarray-like objects which may support index modes.\n*\n* -   Serialization is performed according to host byte order (endianness).\n*\n* -   Meta data format:\n*\n*     ```text\n*     | endianness (1 byte) | <dtype> (2 bytes) | <ndims> (8 bytes) | <shape> (ndims*8 bytes) | <strides> (ndims*8 bytes) | <offset> (8 bytes) | <order> (1 byte) | <mode> (1 byte) | <nsubmodes> (8 bytes) | <submodes> (nsubmodes*1 bytes) | <flags> (4 bytes) |\n*     ```\n*\n*     which translates to the following `ArrayBuffer` layout:\n*\n*     ```text\n*     ArrayBuffer[\n*         <endianness>[int8],\n*         <dtype>[int16],\n*         <ndims>[int64],\n*         <shape>[ndims*int64],\n*         <strides>[ndims*int64],\n*         <offset>[int64],\n*         <order>[int8],\n*         <mode>[int8],\n*         <nsubmodes>[int64],\n*         <submodes>[nsubmodes*int8],\n*         <flags>[int32]\n*     ]\n*     ```\n*\n*     where `strides` and `offset` are in units of bytes.\n*\n* -   If the endianness is `1`, the byte order is little endian. If the endianness is `0`, the byte order is big endian.\n*\n* -   Buffer length:\n*\n*     ```text\n*     1 + 2 + 8 + (ndims*8) + (ndims*8) + 8 + 1 + 1 + 8 + (nsubmodes*1) + 4 = 33 + (ndims*16) + nsubmodes\n*     ```\n*\n*     For example, consider a three-dimensional ndarray with one subscript index mode (submode):\n*\n*     ```text\n*     33 + (3*16) + 1 = 82 bytes\n*     ```\n*\n* -   Views:\n*\n*     -   endianness: `Int8Array( buf, 0, 1 )`\n*     -   dtype: `Int16Array( buf, 1, 1 )`\n*     -   ndims: `Int64Array( buf, 3, 1 )`\n*     -   shape: `Int64Array( buf, 11, ndims )`\n*     -   strides: `Int64Array( buf, 11+(ndims*8), ndims )`\n*     -   offset: `Int64Array( buf, 11+(ndims*16), 1 )`\n*     -   order: `Int8Array( buf, 19+(ndims*16), 1 )`\n*     -   mode: `Int8Array( buf, 20+(ndims*16), 1 )`\n*     -   nsubmodes: `Int64Array( buf, 21+(ndims*16), 1 )`\n*     -   submodes: `Int8Array( buf, 29+(ndims*16), nsubmodes )`\n*     -   flags: `Int32Array( buf, 29+(ndims*16)+nsubmodes, 1 )`\n*\n* @param {ndarrayLike} x - input array\n* @param {string} x.dtype - array data type\n* @param {NonNegativeIntegerArray} x.shape - array shape\n* @param {IntegerArray} x.strides - array strides\n* @param {NonNegativeInteger} x.offset - array index offset\n* @param {string} x.order - array order\n* @param {string} [x.mode='throw'] - array index mode\n* @param {StringArray} [x.submode=[x.mode]] - array subscript index modes\n* @param {Object} [x.flags={}] - array flags\n* @returns {DataView} serialized meta data\n*\n* @example\n* var array = require( '@stdlib/ndarray-array' );\n*\n* var x = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n*\n* var dv = serialize( x );\n* // returns <DataView>\n*/\nfunction serialize( x ) {\n\tvar nbytes;\n\tvar flgs;\n\tvar len;\n\tvar dt;\n\tvar sh;\n\tvar st;\n\tvar sm;\n\tvar v;\n\tvar m;\n\tvar o;\n\tvar s;\n\tvar N;\n\tvar M;\n\tvar i;\n\n\t// Check for interface which does the work of serializing to a DataView for us...\n\tif ( x.__array_meta_dataview__ ) { // eslint-disable-line no-underscore-dangle\n\t\treturn x.__array_meta_dataview__(); // eslint-disable-line no-underscore-dangle\n\t}\n\t// Extract meta data known to be attached to ndarray-like objects:\n\tdt = x.dtype;\n\tsh = x.shape;\n\tst = x.strides;\n\tN = sh.length; // ndims\n\n\t// Extract meta data which may be available on ndarray-like objects (e.g., stdlib ndarray instances):\n\tm = x.mode || 'throw';\n\tsm = x.submode || [ m ];\n\tM = sm.length;\n\n\t// Determine number of bytes per element according to the ndarray dtype:\n\tnbytes = bytesPerElement( dt );\n\n\t// Compute the amount of memory we need to allocate for storing meta data:\n\tlen = 33 + (N*16) + M;\n\n\t// Allocate raw memory and create a view for interfacing with the allocated memory:\n\tv = new DataView( new ArrayBuffer( len ) );\n\n\t// Endianness: (byteoffset: 0; bytelength: 1)\n\to = 0;\n\tv.setInt8( o, ( IS_LITTLE_ENDIAN ) ? 1 : 0 );\n\n\t// Data type: (byteoffset: 1; bytelength: 2)\n\to += 1;\n\tv.setInt16( o, DTYPES[ dt ], IS_LITTLE_ENDIAN );\n\n\t// Number of dimensions: (byteoffset: 3; bytelength: 8)\n\to += 2;\n\tv.setBigInt64( o, BigInt( N ), IS_LITTLE_ENDIAN );\n\n\t// Shape and strides: (byteoffset: 11 and 11+(ndims*8), respectively; bytelength: ndims*8 for both shape and strides, and, thus, ndims*16 total)\n\ts = N * 8; // stride length between a dimension (shape[i]) and its associated stride\n\to += 8;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tv.setBigInt64( o, BigInt( sh[i] ), IS_LITTLE_ENDIAN );\n\t\tv.setBigInt64( o+s, BigInt( st[i]*nbytes ), IS_LITTLE_ENDIAN );\n\t\to += 8;\n\t}\n\t// Offset: (byteoffset: 11+(ndims*16); bytelength: 8)\n\to += s;\n\tv.setBigInt64( o, BigInt( x.offset*nbytes ), IS_LITTLE_ENDIAN );\n\n\t// Order: (byteoffset: 19+(ndims*16); bytelength: 1)\n\to += 8;\n\tv.setInt8( o, ORDERS[ x.order ] );\n\n\t// Index mode: (byteoffset: 20+(ndims*16); bytelength: 1)\n\to += 1;\n\tv.setInt8( o, MODES[ m ] );\n\n\t// Number of index submodes: (byteoffset: 21+(ndims*16); bytelength: 8)\n\to += 1;\n\tv.setBigInt64( o, BigInt( M ), IS_LITTLE_ENDIAN );\n\n\t// Submodes: (byteoffset: 29+(ndims*16); bytelength: nsubmodes*1)\n\to += 8;\n\tfor ( i = 0; i < M; i++ ) {\n\t\tv.setInt8( o, MODES[ sm[i] ] );\n\t\to += 1;\n\t}\n\t// Flags: (byteoffset: 29+(ndims*16)+nsubmodes; bytelength: 4)\n\tflgs = 0|0;\n\tif ( x.flags ) {\n\t\tflgs |= ( x.flags.READONLY ) ? 4 : 0; // 00000000 00000000 00000000 00000100\n\t}\n\tv.setInt32( o, flgs, IS_LITTLE_ENDIAN );\n\n\treturn v;\n}\n\n\n// EXPORTS //\n\nmodule.exports = serialize;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar IS_LITTLE_ENDIAN = require( '@stdlib/assert-is-little-endian' );\nvar float64ToInt64Bytes = require( '@stdlib/number-float64-base-to-int64-bytes' ).assign;\nvar ArrayBuffer = require( '@stdlib/array-buffer' );\nvar Uint8Array = require( '@stdlib/array-uint8' );\nvar DataView = require( '@stdlib/array-dataview' );\nvar bytesPerElement = require( '@stdlib/ndarray-base-bytes-per-element' );\nvar dtypes = require( '@stdlib/ndarray-dtypes' ).enum;\nvar orders = require( '@stdlib/ndarray-orders' ).enum;\nvar modes = require( '@stdlib/ndarray-index-modes' ).enum;\n\n\n// VARIABLES //\n\nvar DTYPES = dtypes();\nvar ORDERS = orders();\nvar MODES = modes();\n\n\n// MAIN //\n\n/**\n* Serializes ndarray meta data.\n*\n* ## Notes\n*\n* -   This function takes into account ndarray-like objects which may support index modes.\n*\n* -   Serialization is performed according to host byte order (endianness).\n*\n* -   Meta data format:\n*\n*     ```text\n*     | endianness (1 byte) | <dtype> (2 bytes) | <ndims> (8 bytes) | <shape> (ndims*8 bytes) | <strides> (ndims*8 bytes) | <offset> (8 bytes) | <order> (1 byte) | <mode> (1 byte) | <nsubmodes> (8 bytes) | <submodes> (nsubmodes*1 bytes) | <flags> (4 bytes) |\n*     ```\n*\n*     which translates to the following `ArrayBuffer` layout:\n*\n*     ```text\n*     ArrayBuffer[\n*         <endianness>[int8],\n*         <dtype>[int16],\n*         <ndims>[int64],\n*         <shape>[ndims*int64],\n*         <strides>[ndims*int64],\n*         <offset>[int64],\n*         <order>[int8],\n*         <mode>[int8],\n*         <nsubmodes>[int64],\n*         <submodes>[nsubmodes*int8],\n*         <flags>[int32]\n*     ]\n*     ```\n*\n*     where `strides` and `offset` are in units of bytes.\n*\n* -   If the endianness is `1`, the byte order is little endian. If the endianness is `0`, the byte order is big endian.\n*\n* -   Buffer length:\n*\n*     ```text\n*     1 + 2 + 8 + (ndims*8) + (ndims*8) + 8 + 1 + 1 + 8 + (nsubmodes*1) = 33 + (ndims*16) + nsubmodes\n*     ```\n*\n*     For example, consider a three-dimensional ndarray with one subscript index mode (submode):\n*\n*     ```text\n*     33 + (3*16) + 1 = 82 bytes\n*     ```\n*\n* -   Views:\n*\n*     -   endianness: `Int8Array( buf, 0, 1 )`\n*     -   dtype: `Int16Array( buf, 1, 1 )`\n*     -   ndims: `Int64Array( buf, 3, 1 )`\n*     -   shape: `Int64Array( buf, 11, ndims )`\n*     -   strides: `Int64Array( buf, 11+(ndims*8), ndims )`\n*     -   offset: `Int64Array( buf, 11+(ndims*16), 1 )`\n*     -   order: `Int8Array( buf, 19+(ndims*16), 1 )`\n*     -   mode: `Int8Array( buf, 20+(ndims*16), 1 )`\n*     -   nsubmodes: `Int64Array( buf, 21+(ndims*16), 1 )`\n*     -   submodes: `Int8Array( buf, 29+(ndims*16), nsubmodes )`\n*     -   flags: `Int32Array( buf, 29+(ndims*16)+nsubmodes, 1 )`\n*\n* @private\n* @param {ndarrayLike} x - input array\n* @param {string} x.dtype - array data type\n* @param {NonNegativeIntegerArray} x.shape - array shape\n* @param {IntegerArray} x.strides - array strides\n* @param {NonNegativeInteger} x.offset - array index offset\n* @param {string} x.order - array order\n* @param {string} [x.mode='throw'] - array index mode\n* @param {StringArray} [x.submode=[x.mode]] - array subscript index modes\n* @param {Object} [x.flags={}] - array flags\n* @returns {DataView} serialized meta data\n*\n* @example\n* var array = require( '@stdlib/ndarray-array' );\n*\n* var x = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n*\n* var dv = serialize( x );\n* // returns <DataView>\n*/\nfunction serialize( x ) {\n\tvar nbytes;\n\tvar bytes;\n\tvar flgs;\n\tvar len;\n\tvar dt;\n\tvar sh;\n\tvar st;\n\tvar sm;\n\tvar v;\n\tvar m;\n\tvar o;\n\tvar s;\n\tvar N;\n\tvar M;\n\tvar i;\n\n\t// Check for interface which does the work of serializing to a DataView for us...\n\tif ( x.__array_meta_dataview__ ) { // eslint-disable-line no-underscore-dangle\n\t\treturn x.__array_meta_dataview__(); // eslint-disable-line no-underscore-dangle\n\t}\n\t// Extract meta data known to be attached to ndarray-like objects:\n\tdt = x.dtype;\n\tsh = x.shape;\n\tst = x.strides;\n\tN = sh.length; // ndims\n\n\t// Extract meta data which may be available on ndarray-like objects (e.g., stdlib ndarray instances):\n\tm = x.mode || 'throw';\n\tsm = x.submode || [ m ];\n\tM = sm.length;\n\n\t// Determine number of bytes per element according to the ndarray dtype:\n\tnbytes = bytesPerElement( dt );\n\n\t// Compute the amount of memory we need to allocate for storing meta data:\n\tlen = 33 + (N*16) + M;\n\n\t// Allocate raw memory and create a view for interfacing with the allocated memory:\n\tv = new DataView( new ArrayBuffer( len ) );\n\tbytes = new Uint8Array( v.buffer );\n\n\t// Endianness: (byteoffset: 0; bytelength: 1)\n\to = 0;\n\tv.setInt8( o, ( IS_LITTLE_ENDIAN ) ? 1 : 0 );\n\n\t// Data type: (byteoffset: 1; bytelength: 2)\n\to += 1;\n\tv.setInt16( o, DTYPES[ dt ], IS_LITTLE_ENDIAN );\n\n\t// Number of dimensions: (byteoffset: 3; bytelength: 8)\n\to += 2;\n\tfloat64ToInt64Bytes( N, bytes, 1, o );\n\n\t// Shape and strides: (byteoffset: 11 and 11+(ndims*8), respectively; bytelength: ndims*8 for both shape and strides, and, thus, ndims*16 total)\n\ts = N * 8; // stride length between a dimension (shape[i]) and its associated stride\n\to += 8;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tfloat64ToInt64Bytes( sh[i], bytes, 1, o );\n\t\tfloat64ToInt64Bytes( st[i]*nbytes, bytes, 1, o+s );\n\t\to += 8;\n\t}\n\t// Offset: (byteoffset: 11+(ndims*16); bytelength: 8)\n\to += s;\n\tfloat64ToInt64Bytes( x.offset*nbytes, bytes, 1, o );\n\n\t// Order: (byteoffset: 19+(ndims*16); bytelength: 1)\n\to += 8;\n\tv.setInt8( o, ORDERS[ x.order ] );\n\n\t// Index mode: (byteoffset: 20+(ndims*16); bytelength: 1)\n\to += 1;\n\tv.setInt8( o, MODES[ m ] );\n\n\t// Number of index submodes: (byteoffset: 21+(ndims*16); bytelength: 8)\n\to += 1;\n\tfloat64ToInt64Bytes( M, bytes, 1, o );\n\n\t// Submodes: (byteoffset: 29+(ndims*16); bytelength: nsubmodes*1)\n\to += 8;\n\tfor ( i = 0; i < M; i++ ) {\n\t\tv.setInt8( o, MODES[ sm[i] ] );\n\t\to += 1;\n\t}\n\t// Flags: (byteoffset: 29+(ndims*16)+nsubmodes; bytelength: 4)\n\tflgs = 0|0;\n\tif ( x.flags ) {\n\t\tflgs |= ( x.flags.READONLY ) ? 4 : 0; // 00000000 00000000 00000000 00000100\n\t}\n\tv.setInt32( o, flgs, IS_LITTLE_ENDIAN );\n\n\treturn v;\n}\n\n\n// EXPORTS //\n\nmodule.exports = serialize;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Serialize ndarray meta data.\n*\n* @module @stdlib/ndarray-base-serialize-meta-data\n*\n* @example\n* var array = require( '@stdlib/ndarray-array' );\n* var serialize = require( '@stdlib/ndarray-base-serialize-meta-data' );\n*\n* var x = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n*\n* var dv = serialize( x );\n* // returns <DataView>\n*/\n\n// MODULES //\n\nvar hasBigIntSupport = require( '@stdlib/assert-has-bigint-support' );\nvar builtin = require( './main.js' );\nvar polyfill = require( './polyfill.js' );\n\n\n// MAIN //\n\nvar main;\nif ( hasBigIntSupport() ) {\n\tmain = builtin;\n} else {\n\tmain = polyfill;\n}\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_main", "__commonJSMin", "exports", "module", "IS_LITTLE_ENDIAN", "ArrayBuffer", "DataView", "BigInt", "bytesPerElement", "dtypes", "orders", "modes", "DTYPES", "ORDERS", "MODES", "serialize", "x", "nbytes", "flgs", "len", "dt", "sh", "st", "sm", "v", "m", "o", "s", "N", "M", "i", "require_polyfill", "__commonJSMin", "exports", "module", "IS_LITTLE_ENDIAN", "float64ToInt64Bytes", "ArrayBuffer", "Uint8Array", "DataView", "bytesPerElement", "dtypes", "orders", "modes", "DTYPES", "ORDERS", "MODES", "serialize", "x", "nbytes", "bytes", "flgs", "len", "dt", "sh", "st", "sm", "m", "o", "s", "N", "M", "i", "hasBigIntSupport", "builtin", "polyfill", "main"]
}
