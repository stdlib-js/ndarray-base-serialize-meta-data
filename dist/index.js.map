{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/polyfill.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar IS_LITTLE_ENDIAN = require( '@stdlib/assert-is-little-endian' );\nvar ArrayBuffer = require( '@stdlib/array-buffer' );\nvar DataView = require( '@stdlib/array-dataview' );\nvar BigInt = require( '@stdlib/bigint-ctor' );\nvar bytesPerElement = require( '@stdlib/ndarray-base-bytes-per-element' );\nvar dtypes = require( '@stdlib/ndarray-base-dtype-enums' );\nvar orders = require( '@stdlib/ndarray-orders' ).enum;\nvar modes = require( '@stdlib/ndarray-index-modes' ).enum;\nvar getDType = require( '@stdlib/ndarray-base-dtype' );\nvar getShape = require( '@stdlib/ndarray-base-shape' );\nvar getStrides = require( '@stdlib/ndarray-base-strides' );\nvar getOffset = require( '@stdlib/ndarray-base-offset' );\nvar getOrder = require( '@stdlib/ndarray-base-order' );\n\n\n// VARIABLES //\n\nvar DTYPES = dtypes();\nvar ORDERS = orders();\nvar MODES = modes();\n\n\n// MAIN //\n\n/**\n* Serializes ndarray meta data.\n*\n* ## Notes\n*\n* -   This function takes into account ndarray-like objects which may support index modes.\n*\n* -   Serialization is performed according to host byte order (endianness).\n*\n* -   Meta data format:\n*\n*     ```text\n*     | endianness (1 byte) | <dtype> (2 bytes) | <ndims> (8 bytes) | <shape> (ndims*8 bytes) | <strides> (ndims*8 bytes) | <offset> (8 bytes) | <order> (1 byte) | <mode> (1 byte) | <nsubmodes> (8 bytes) | <submodes> (nsubmodes*1 bytes) | <flags> (4 bytes) |\n*     ```\n*\n*     which translates to the following `ArrayBuffer` layout:\n*\n*     ```text\n*     ArrayBuffer[\n*         <endianness>[int8],\n*         <dtype>[int16],\n*         <ndims>[int64],\n*         <shape>[ndims*int64],\n*         <strides>[ndims*int64],\n*         <offset>[int64],\n*         <order>[int8],\n*         <mode>[int8],\n*         <nsubmodes>[int64],\n*         <submodes>[nsubmodes*int8],\n*         <flags>[int32]\n*     ]\n*     ```\n*\n*     where `strides` and `offset` are in units of bytes.\n*\n* -   If the endianness is `1`, the byte order is little endian. If the endianness is `0`, the byte order is big endian.\n*\n* -   Buffer length:\n*\n*     ```text\n*     1 + 2 + 8 + (ndims*8) + (ndims*8) + 8 + 1 + 1 + 8 + (nsubmodes*1) + 4 = 33 + (ndims*16) + nsubmodes\n*     ```\n*\n*     For example, consider a three-dimensional ndarray with one subscript index mode (submode):\n*\n*     ```text\n*     33 + (3*16) + 1 = 82 bytes\n*     ```\n*\n* -   Views:\n*\n*     -   endianness: `Int8Array( buf, 0, 1 )`\n*     -   dtype: `Int16Array( buf, 1, 1 )`\n*     -   ndims: `Int64Array( buf, 3, 1 )`\n*     -   shape: `Int64Array( buf, 11, ndims )`\n*     -   strides: `Int64Array( buf, 11+(ndims*8), ndims )`\n*     -   offset: `Int64Array( buf, 11+(ndims*16), 1 )`\n*     -   order: `Int8Array( buf, 19+(ndims*16), 1 )`\n*     -   mode: `Int8Array( buf, 20+(ndims*16), 1 )`\n*     -   nsubmodes: `Int64Array( buf, 21+(ndims*16), 1 )`\n*     -   submodes: `Int8Array( buf, 29+(ndims*16), nsubmodes )`\n*     -   flags: `Int32Array( buf, 29+(ndims*16)+nsubmodes, 1 )`\n*\n* @param {ndarrayLike} x - input array\n* @param {string} x.dtype - array data type\n* @param {NonNegativeIntegerArray} x.shape - array shape\n* @param {IntegerArray} x.strides - array strides\n* @param {NonNegativeInteger} x.offset - array index offset\n* @param {string} x.order - array order\n* @param {string} [x.mode='throw'] - array index mode\n* @param {StringArray} [x.submode=[x.mode]] - array subscript index modes\n* @param {Object} [x.flags={}] - array flags\n* @returns {DataView} serialized meta data\n*\n* @example\n* var array = require( '@stdlib/ndarray-array' );\n*\n* var x = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n*\n* var dv = serialize( x );\n* // returns <DataView>\n*/\nfunction serialize( x ) {\n\tvar nbytes;\n\tvar flgs;\n\tvar len;\n\tvar dt;\n\tvar sh;\n\tvar st;\n\tvar sm;\n\tvar v;\n\tvar m;\n\tvar o;\n\tvar s;\n\tvar N;\n\tvar M;\n\tvar i;\n\n\t// Check for interface which does the work of serializing to a DataView for us...\n\tif ( x.__array_meta_dataview__ ) { // eslint-disable-line no-underscore-dangle\n\t\treturn x.__array_meta_dataview__(); // eslint-disable-line no-underscore-dangle\n\t}\n\t// Extract meta data known to be attached to ndarray-like objects:\n\tdt = getDType( x );\n\tsh = getShape( x, false );\n\tst = getStrides( x, false );\n\tN = sh.length; // ndims\n\n\t// Extract meta data which may be available on ndarray-like objects (e.g., stdlib ndarray instances):\n\tm = x.mode || 'throw';\n\tsm = x.submode || [ m ];\n\tM = sm.length;\n\n\t// Determine number of bytes per element according to the ndarray dtype:\n\tnbytes = bytesPerElement( dt );\n\n\t// Compute the amount of memory we need to allocate for storing meta data:\n\tlen = 33 + (N*16) + M;\n\n\t// Allocate raw memory and create a view for interfacing with the allocated memory:\n\tv = new DataView( new ArrayBuffer( len ) );\n\n\t// Endianness: (byteoffset: 0; bytelength: 1)\n\to = 0;\n\tv.setInt8( o, ( IS_LITTLE_ENDIAN ) ? 1 : 0 );\n\n\t// Data type: (byteoffset: 1; bytelength: 2)\n\to += 1;\n\tv.setInt16( o, DTYPES[ dt ], IS_LITTLE_ENDIAN );\n\n\t// Number of dimensions: (byteoffset: 3; bytelength: 8)\n\to += 2;\n\tv.setBigInt64( o, BigInt( N ), IS_LITTLE_ENDIAN );\n\n\t// Shape and strides: (byteoffset: 11 and 11+(ndims*8), respectively; bytelength: ndims*8 for both shape and strides, and, thus, ndims*16 total)\n\ts = N * 8; // stride length between a dimension (shape[i]) and its associated stride\n\to += 8;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tv.setBigInt64( o, BigInt( sh[i] ), IS_LITTLE_ENDIAN );\n\t\tv.setBigInt64( o+s, BigInt( st[i]*nbytes ), IS_LITTLE_ENDIAN );\n\t\to += 8;\n\t}\n\t// Offset: (byteoffset: 11+(ndims*16); bytelength: 8)\n\to += s;\n\tv.setBigInt64( o, BigInt( getOffset( x )*nbytes ), IS_LITTLE_ENDIAN );\n\n\t// Order: (byteoffset: 19+(ndims*16); bytelength: 1)\n\to += 8;\n\tv.setInt8( o, ORDERS[ getOrder( x ) ] );\n\n\t// Index mode: (byteoffset: 20+(ndims*16); bytelength: 1)\n\to += 1;\n\tv.setInt8( o, MODES[ m ] );\n\n\t// Number of index submodes: (byteoffset: 21+(ndims*16); bytelength: 8)\n\to += 1;\n\tv.setBigInt64( o, BigInt( M ), IS_LITTLE_ENDIAN );\n\n\t// Submodes: (byteoffset: 29+(ndims*16); bytelength: nsubmodes*1)\n\to += 8;\n\tfor ( i = 0; i < M; i++ ) {\n\t\tv.setInt8( o, MODES[ sm[i] ] );\n\t\to += 1;\n\t}\n\t// Flags: (byteoffset: 29+(ndims*16)+nsubmodes; bytelength: 4)\n\tflgs = 0|0;\n\tif ( x.flags ) {\n\t\tflgs |= ( x.flags.READONLY ) ? 4 : 0; // 00000000 00000000 00000000 00000100\n\t}\n\tv.setInt32( o, flgs, IS_LITTLE_ENDIAN );\n\n\treturn v;\n}\n\n\n// EXPORTS //\n\nmodule.exports = serialize;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar IS_LITTLE_ENDIAN = require( '@stdlib/assert-is-little-endian' );\nvar float64ToInt64Bytes = require( '@stdlib/number-float64-base-to-int64-bytes' ).assign;\nvar ArrayBuffer = require( '@stdlib/array-buffer' );\nvar Uint8Array = require( '@stdlib/array-uint8' );\nvar DataView = require( '@stdlib/array-dataview' );\nvar bytesPerElement = require( '@stdlib/ndarray-base-bytes-per-element' );\nvar dtypes = require( '@stdlib/ndarray-base-dtype-enums' );\nvar orders = require( '@stdlib/ndarray-orders' ).enum;\nvar modes = require( '@stdlib/ndarray-index-modes' ).enum;\nvar getDType = require( '@stdlib/ndarray-base-dtype' );\nvar getShape = require( '@stdlib/ndarray-base-shape' );\nvar getStrides = require( '@stdlib/ndarray-base-strides' );\nvar getOffset = require( '@stdlib/ndarray-base-offset' );\nvar getOrder = require( '@stdlib/ndarray-base-order' );\n\n\n// VARIABLES //\n\nvar DTYPES = dtypes();\nvar ORDERS = orders();\nvar MODES = modes();\n\n\n// MAIN //\n\n/**\n* Serializes ndarray meta data.\n*\n* ## Notes\n*\n* -   This function takes into account ndarray-like objects which may support index modes.\n*\n* -   Serialization is performed according to host byte order (endianness).\n*\n* -   Meta data format:\n*\n*     ```text\n*     | endianness (1 byte) | <dtype> (2 bytes) | <ndims> (8 bytes) | <shape> (ndims*8 bytes) | <strides> (ndims*8 bytes) | <offset> (8 bytes) | <order> (1 byte) | <mode> (1 byte) | <nsubmodes> (8 bytes) | <submodes> (nsubmodes*1 bytes) | <flags> (4 bytes) |\n*     ```\n*\n*     which translates to the following `ArrayBuffer` layout:\n*\n*     ```text\n*     ArrayBuffer[\n*         <endianness>[int8],\n*         <dtype>[int16],\n*         <ndims>[int64],\n*         <shape>[ndims*int64],\n*         <strides>[ndims*int64],\n*         <offset>[int64],\n*         <order>[int8],\n*         <mode>[int8],\n*         <nsubmodes>[int64],\n*         <submodes>[nsubmodes*int8],\n*         <flags>[int32]\n*     ]\n*     ```\n*\n*     where `strides` and `offset` are in units of bytes.\n*\n* -   If the endianness is `1`, the byte order is little endian. If the endianness is `0`, the byte order is big endian.\n*\n* -   Buffer length:\n*\n*     ```text\n*     1 + 2 + 8 + (ndims*8) + (ndims*8) + 8 + 1 + 1 + 8 + (nsubmodes*1) = 33 + (ndims*16) + nsubmodes\n*     ```\n*\n*     For example, consider a three-dimensional ndarray with one subscript index mode (submode):\n*\n*     ```text\n*     33 + (3*16) + 1 = 82 bytes\n*     ```\n*\n* -   Views:\n*\n*     -   endianness: `Int8Array( buf, 0, 1 )`\n*     -   dtype: `Int16Array( buf, 1, 1 )`\n*     -   ndims: `Int64Array( buf, 3, 1 )`\n*     -   shape: `Int64Array( buf, 11, ndims )`\n*     -   strides: `Int64Array( buf, 11+(ndims*8), ndims )`\n*     -   offset: `Int64Array( buf, 11+(ndims*16), 1 )`\n*     -   order: `Int8Array( buf, 19+(ndims*16), 1 )`\n*     -   mode: `Int8Array( buf, 20+(ndims*16), 1 )`\n*     -   nsubmodes: `Int64Array( buf, 21+(ndims*16), 1 )`\n*     -   submodes: `Int8Array( buf, 29+(ndims*16), nsubmodes )`\n*     -   flags: `Int32Array( buf, 29+(ndims*16)+nsubmodes, 1 )`\n*\n* @private\n* @param {ndarrayLike} x - input array\n* @param {string} x.dtype - array data type\n* @param {NonNegativeIntegerArray} x.shape - array shape\n* @param {IntegerArray} x.strides - array strides\n* @param {NonNegativeInteger} x.offset - array index offset\n* @param {string} x.order - array order\n* @param {string} [x.mode='throw'] - array index mode\n* @param {StringArray} [x.submode=[x.mode]] - array subscript index modes\n* @param {Object} [x.flags={}] - array flags\n* @returns {DataView} serialized meta data\n*\n* @example\n* var array = require( '@stdlib/ndarray-array' );\n*\n* var x = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n*\n* var dv = serialize( x );\n* // returns <DataView>\n*/\nfunction serialize( x ) {\n\tvar nbytes;\n\tvar bytes;\n\tvar flgs;\n\tvar len;\n\tvar dt;\n\tvar sh;\n\tvar st;\n\tvar sm;\n\tvar v;\n\tvar m;\n\tvar o;\n\tvar s;\n\tvar N;\n\tvar M;\n\tvar i;\n\n\t// Check for interface which does the work of serializing to a DataView for us...\n\tif ( x.__array_meta_dataview__ ) { // eslint-disable-line no-underscore-dangle\n\t\treturn x.__array_meta_dataview__(); // eslint-disable-line no-underscore-dangle\n\t}\n\t// Extract meta data known to be attached to ndarray-like objects:\n\tdt = getDType( x);\n\tsh = getShape( x, false );\n\tst = getStrides( x, false );\n\tN = sh.length; // ndims\n\n\t// Extract meta data which may be available on ndarray-like objects (e.g., stdlib ndarray instances):\n\tm = x.mode || 'throw';\n\tsm = x.submode || [ m ];\n\tM = sm.length;\n\n\t// Determine number of bytes per element according to the ndarray dtype:\n\tnbytes = bytesPerElement( dt );\n\n\t// Compute the amount of memory we need to allocate for storing meta data:\n\tlen = 33 + (N*16) + M;\n\n\t// Allocate raw memory and create a view for interfacing with the allocated memory:\n\tv = new DataView( new ArrayBuffer( len ) );\n\tbytes = new Uint8Array( v.buffer );\n\n\t// Endianness: (byteoffset: 0; bytelength: 1)\n\to = 0;\n\tv.setInt8( o, ( IS_LITTLE_ENDIAN ) ? 1 : 0 );\n\n\t// Data type: (byteoffset: 1; bytelength: 2)\n\to += 1;\n\tv.setInt16( o, DTYPES[ dt ], IS_LITTLE_ENDIAN );\n\n\t// Number of dimensions: (byteoffset: 3; bytelength: 8)\n\to += 2;\n\tfloat64ToInt64Bytes( N, bytes, 1, o );\n\n\t// Shape and strides: (byteoffset: 11 and 11+(ndims*8), respectively; bytelength: ndims*8 for both shape and strides, and, thus, ndims*16 total)\n\ts = N * 8; // stride length between a dimension (shape[i]) and its associated stride\n\to += 8;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tfloat64ToInt64Bytes( sh[i], bytes, 1, o );\n\t\tfloat64ToInt64Bytes( st[i]*nbytes, bytes, 1, o+s );\n\t\to += 8;\n\t}\n\t// Offset: (byteoffset: 11+(ndims*16); bytelength: 8)\n\to += s;\n\tfloat64ToInt64Bytes( getOffset( x )*nbytes, bytes, 1, o );\n\n\t// Order: (byteoffset: 19+(ndims*16); bytelength: 1)\n\to += 8;\n\tv.setInt8( o, ORDERS[ getOrder( x ) ] );\n\n\t// Index mode: (byteoffset: 20+(ndims*16); bytelength: 1)\n\to += 1;\n\tv.setInt8( o, MODES[ m ] );\n\n\t// Number of index submodes: (byteoffset: 21+(ndims*16); bytelength: 8)\n\to += 1;\n\tfloat64ToInt64Bytes( M, bytes, 1, o );\n\n\t// Submodes: (byteoffset: 29+(ndims*16); bytelength: nsubmodes*1)\n\to += 8;\n\tfor ( i = 0; i < M; i++ ) {\n\t\tv.setInt8( o, MODES[ sm[i] ] );\n\t\to += 1;\n\t}\n\t// Flags: (byteoffset: 29+(ndims*16)+nsubmodes; bytelength: 4)\n\tflgs = 0|0;\n\tif ( x.flags ) {\n\t\tflgs |= ( x.flags.READONLY ) ? 4 : 0; // 00000000 00000000 00000000 00000100\n\t}\n\tv.setInt32( o, flgs, IS_LITTLE_ENDIAN );\n\n\treturn v;\n}\n\n\n// EXPORTS //\n\nmodule.exports = serialize;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Serialize ndarray meta data.\n*\n* @module @stdlib/ndarray-base-serialize-meta-data\n*\n* @example\n* var array = require( '@stdlib/ndarray-array' );\n* var serialize = require( '@stdlib/ndarray-base-serialize-meta-data' );\n*\n* var x = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n*\n* var dv = serialize( x );\n* // returns <DataView>\n*/\n\n// MODULES //\n\nvar hasBigIntSupport = require( '@stdlib/assert-has-bigint-support' );\nvar builtin = require( './main.js' );\nvar polyfill = require( './polyfill.js' );\n\n\n// MAIN //\n\nvar main;\nif ( hasBigIntSupport() ) {\n\tmain = builtin;\n} else {\n\tmain = polyfill;\n}\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_main", "__commonJSMin", "exports", "module", "IS_LITTLE_ENDIAN", "ArrayBuffer", "DataView", "BigInt", "bytesPerElement", "dtypes", "orders", "modes", "getDType", "getShape", "getStrides", "getOffset", "getOrder", "DTYPES", "ORDERS", "MODES", "serialize", "x", "nbytes", "flgs", "len", "dt", "sh", "st", "sm", "v", "m", "o", "s", "N", "M", "i", "require_polyfill", "__commonJSMin", "exports", "module", "IS_LITTLE_ENDIAN", "float64ToInt64Bytes", "ArrayBuffer", "Uint8Array", "DataView", "bytesPerElement", "dtypes", "orders", "modes", "getDType", "getShape", "getStrides", "getOffset", "getOrder", "DTYPES", "ORDERS", "MODES", "serialize", "x", "nbytes", "bytes", "flgs", "len", "dt", "sh", "st", "sm", "v", "m", "o", "s", "N", "M", "i", "hasBigIntSupport", "builtin", "polyfill", "main"]
}
